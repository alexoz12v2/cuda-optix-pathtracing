Invocations                               Metric Name                            Metric Description         Min         Max         Avg
Device "NVIDIA GeForce GTX 1070 (0)"
    Kernel: pathTraceMegakernel(DeviceCamera*, TriangleSoup, Light const *, unsigned int, Light const *, unsigned int, BSDF const *, unsigned int, unsigned int, DeviceHaltonOwen*, DeviceOutputBuffer)
         20                             flop_count_sp   Floating Point Operations(Single Precision)  4657636395  4718319604  4699306874
         20                    dram_read_transactions               Device Memory Read Transactions      930177     1285768     1149149
         20                   dram_write_transactions              Device Memory Write Transactions      168612      390154      341311


MK: 
  X: 4699306874 / ((1149149 + 341311) * 32)
  Y: 4699306874 / (15546 * 80 / 2048)
  
  
  Execution time
Tms=15546√ó802048=1,243,6802048‚âà607.1 ms
T
ms
	‚Äã

=
2048
15546√ó80
	‚Äã

=
2048
1,243,680
	‚Äã

‚âà607.1 ms

‚úÖ So execution time 
T‚âà607.1 ms
T‚âà607.1 ms

2Ô∏è‚É£ Compute Arithmetic Intensity (FLOPs/Byte)

Arithmetic intensity:

AI=FLOPsBytes read + written
AI=
Bytes read + written
FLOPs
	‚Äã

Step 2a: Memory traffic

Read transactions: 1,149,149

Write transactions: 341,311

Each transaction = 32 bytes (typical DRAM transaction for CUDA device reads/writes)

Bytes=(1,149,149+341,311)√ó32
Bytes=(1,149,149+341,311)√ó32

Sum transactions:

1,149,149+341,311=1,490,460
1,149,149+341,311=1,490,460

Multiply by 32 bytes:

1,490,460√ó32=47,694,720 bytes
1,490,460√ó32=47,694,720 bytes
Step 2b: Compute AI
AI=4,699,306,87447,694,720‚âà98.48 FLOPs/Byte
AI=
47,694,720
4,699,306,874
	‚Äã

‚âà98.48 FLOPs/Byte

------------------------------------------------------------------------------------

Device "NVIDIA GeForce GTX 1070 (0)"
    Kernel: checkDoneDepth(DeviceArena<PathState>, SimpleDeviceQueue<ClosestHitInput>, SimpleDeviceQueue<MissInput>, SimpleDeviceQueue<AnyhitInput>, SimpleDeviceQueue<ShadeInput>, int*)
      25238                             flop_count_sp   Floating Point Operations(Single Precision)           0           0           0
      25238                    dram_read_transactions               Device Memory Read Transactions        4261      184930       13326
      25238                   dram_write_transactions              Device Memory Write Transactions           0      111748         500
    Kernel: anyhitKernel(SimpleDeviceQueue<AnyhitInput>, Light*, unsigned int, BSDF*, TriangleSoup)
      25238                             flop_count_sp   Floating Point Operations(Single Precision)           0     4040863      671887
      25238                    dram_read_transactions               Device Memory Read Transactions          31       29966        2786
      25238                   dram_write_transactions              Device Memory Write Transactions           0       40832        1015
    Kernel: missKernel(SimpleDeviceQueue<MissInput>, DeviceArena<PathState>, DeviceOutputBuffer, Light*, unsigned int)
      25238                             flop_count_sp   Floating Point Operations(Single Precision)           0       21008        1148
      25238                    dram_read_transactions               Device Memory Read Transactions          32        8085         485
      25238                   dram_write_transactions              Device Memory Write Transactions           0        5024         262
    Kernel: closesthitKernel(SimpleDeviceQueue<ClosestHitInput>, SimpleDeviceQueue<MissInput>, SimpleDeviceQueue<AnyhitInput>, SimpleDeviceQueue<ShadeInput>, TriangleSoup)
      25239                             flop_count_sp   Floating Point Operations(Single Precision)           0     3556477      657091
      25239                    dram_read_transactions               Device Memory Read Transactions          28       18054        1193
      25239                   dram_write_transactions              Device Memory Write Transactions           0       22319        1351
    Kernel: shadeKernel(SimpleDeviceQueue<ShadeInput>, SimpleDeviceQueue<ClosestHitInput>, DeviceArena<PathState>, DeviceOutputBuffer, BSDF*)
      25238                             flop_count_sp   Floating Point Operations(Single Precision)           0      578759       84361
      25238                    dram_read_transactions               Device Memory Read Transactions          29       19820        2399
      25238                   dram_write_transactions              Device Memory Write Transactions           0       10444        1352
    Kernel: raygenKernel(SimpleDeviceQueue<ClosestHitInput>, DeviceArena<PathState>, DeviceHaltonOwen*, DeviceCamera*, int, int, int, int, int)
       1374                             flop_count_sp   Floating Point Operations(Single Precision)      217472      265216      251898
       1374                    dram_read_transactions               Device Memory Read Transactions         564      227059       34830
       1374                   dram_write_transactions              Device Memory Write Transactions        1624       61780        5740


4Ô∏è‚É£ How to compute the single WF roofline point
Step 1 ‚Äî Total FLOPs

Sum average flop_count_sp over all kernels:

FLOPsWF=‚àëkflop_count_sp(k)
FLOPs
WF
	‚Äã

=
k
‚àë
	‚Äã

flop_count_sp
(k)

From your data (averages column):

raygenKernel ‚âà 251,898

anyhitKernel ‚âà 671,887

closesthitKernel ‚âà 657,091

shadeKernel ‚âà 84,361

missKernel ‚âà 1,148

checkDoneDepth = 0

FLOPsWF‚âà1.67√ó106
FLOPs
WF
	‚Äã

‚âà1.67√ó10
6

‚ö†Ô∏è This is per kernel launch, not per full render ‚Äî see time below.

Step 2 ‚Äî Total memory traffic

Sum all read + write transactions:

TransactionsWF=‚àëk(readsk+writesk)
Transactions
WF
	‚Äã

=
k
‚àë
	‚Äã

(reads
k
	‚Äã

+writes
k
	‚Äã

)

Multiply by 32 bytes per transaction (Pascal DRAM):

BytesWF=TransactionsWF√ó32
Bytes
WF
	‚Äã

=Transactions
WF
	‚Äã

√ó32

This will be large, because wavefront is queue-heavy.

Step 3 ‚Äî Arithmetic Intensity
AIWF=Total FLOPsTotal Bytes
AI
WF
	‚Äã

=
Total Bytes
Total FLOPs
	‚Äã

	‚Äã


üëâ Expect this to be much lower than dmt-mk v2
(very likely memory-bound)

This is exactly the point of comparing MK vs WF.

Step 4 ‚Äî Performance (GFLOPS)

Use wall-clock time for the full wavefront iteration:

GFLOPSWF=Total FLOPsTWF
GFLOPS
WF
	‚Äã

=
T
WF
	‚Äã

Total FLOPs
	‚Äã


Where:

TWF
T
WF
	‚Äã

 = total time for all wavefront kernels, including synchronization and compaction

‚ö†Ô∏è Do not sum kernel times individually if overlap exists ‚Äî prefer:

Nsight Compute range

or host-side timing around the wavefront loop

5Ô∏è‚É£ How this looks on the roofline (interpretation)

You will end up with:

Implementation	AI	GFLOPS	Region
dmt-mk v2	~98	~7.7 TFLOPS	Compute-bound
dmt-wf v2	low (‚âà1‚Äì10)	much lower	Memory-bound

This visually demonstrates:

MK ‚Üí high instruction density, poor flexibility

WF ‚Üí better divergence control, but memory traffic dominates

That‚Äôs a textbook roofline comparison.

2Ô∏è‚É£ Aggregate FLOPs (average column)

From your data (average values):

Kernel	FLOPs
checkDoneDepth	0
anyhitKernel	671,887
missKernel	1,148
closesthitKernel	657,091
shadeKernel	84,361
raygenKernel	251,898
Total FLOPs (WF iteration)
FLOPsWF=671,887+1,148+657,091+84,361+251,898
FLOPs
WF
	‚Äã

=671,887+1,148+657,091+84,361+251,898
FLOPsWF=1,666,385
FLOPs
WF
	‚Äã

=1,666,385
	‚Äã

3Ô∏è‚É£ Aggregate DRAM transactions
Reads + writes per kernel
Kernel	Reads	Writes
checkDoneDepth	13,326	500
anyhitKernel	2,786	1,015
missKernel	485	262
closesthitKernel	1,193	1,351
shadeKernel	2,399	1,352
raygenKernel	34,830	5,740
Sum all transactions

Reads:

13,326+2,786+485+1,193+2,399+34,830=55,019
13,326+2,786+485+1,193+2,399+34,830=55,019

Writes:

500+1,015+262+1,351+1,352+5,740=10,220
500+1,015+262+1,351+1,352+5,740=10,220
Total DRAM transactions
TransactionsWF=55,019+10,220=65,239
Transactions
WF
	‚Äã

=55,019+10,220=65,239
4Ô∏è‚É£ Convert transactions ‚Üí bytes

On Pascal:

1 DRAM transaction = 32 bytes

BytesWF=65,239√ó32
Bytes
WF
	‚Äã

=65,239√ó32
BytesWF=2,087,648 bytes
Bytes
WF
	‚Äã

=2,087,648 bytes
	‚Äã

5Ô∏è‚É£ Arithmetic Intensity (FINAL)
AIWF=1,666,3852,087,648
AI
WF
	‚Äã

=
2,087,648
1,666,385
	‚Äã

AIWF‚âà0.80 FLOPs/Byte
AI
WF
	‚Äã

‚âà0.80 FLOPs/Byte
	‚Äã

‚úÖ Final Result (Wavefront)
Metric	Value
Arithmetic Intensity	‚âà 0.80 FLOPs/Byte
Ridge Point (GTX 1070)	‚âà 31.95 FLOPs/Byte
Regime	Strongly Memory Bound
6Ô∏è‚É£ Sanity check (important)

This result makes perfect sense:

Megakernel: ~98 FLOPs/Byte

Wavefront: ~0.8 FLOPs/Byte

That is a 2 orders of magnitude difference, explained by:

queues

compaction

atomics

global memory traffic

kernel boundaries

This is exactly what roofline analysis is meant to show.

1Ô∏è‚É£ Convert execution time to 80 samples

Given:

Measured time: 436,328 ms for 2048 samples

We want time for 80 samples

Scaling is linear:

T80=436,328√ó802048
T
80
	‚Äã

=436,328√ó
2048
80
	‚Äã

T80=436,328√ó0.0390625‚âà17,043 ms
T
80
	‚Äã

=436,328√ó0.0390625‚âà17,043 ms
T80‚âà17.04 s
T
80
	‚Äã

‚âà17.04 s
	‚Äã

2Ô∏è‚É£ FLOPs (already computed)

From the aggregated kernel data:

FLOPsWF,80=1,666,385
FLOPs
WF,80
	‚Äã

=1,666,385
	‚Äã


(This is correct because your nvprof run was done at 80 samples.)

3Ô∏è‚É£ Compute GFLOPS
GFLOPSWF=1,666,38517.043√ó109
GFLOPS
WF
	‚Äã

=
17.043√ó10
9
1,666,385
	‚Äã

GFLOPSWF‚âà0.000098
GFLOPS
WF
	‚Äã

‚âà0.000098
	‚Äã


Or more readably:

GFLOPSWF‚âà9.8√ó10‚àí5
GFLOPS
WF
	‚Äã

‚âà9.8√ó10
‚àí5
	‚Äã

4Ô∏è‚É£ Final Wavefront Roofline Point
Metric	Value
Arithmetic Intensity	0.80 FLOPs/Byte
Performance	0.000098 GFLOPS
Performance	‚âà 98 MFLOPS
Regime	Strongly Memory Bound\
